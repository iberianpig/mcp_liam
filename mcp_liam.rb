#!/usr/bin/env ruby

# MCP Liam - Database Schema MCP Server
#
# This MCP server provides tools to analyze database schema generated by liam.
# https://github.com/liam-hq/liam
#
# Usage:
#   chmod +x mcp_liam.rb
#   ./mcp_liam.rb
#
# .mcp.json configuration:
# {
#   "mcpServers": {
#     "liam": {
#       "command": "ruby",
#       "args": ["/path/to/mcp_liam.rb"],
#       "env": {
#         "SCHEMA_PATH": "/path/to/schema.json"
#       }
#     }
#   }
# }

require 'bundler/inline'

gemfile(true, quiet: true) do
  source "https://rubygems.org"
  gem "mcp"
  gem "json"
end

require 'mcp'
require 'mcp/server/transports/stdio_transport'
require 'json'

# SchemaLoader loads and manages the database schema
class SchemaLoader
  attr_reader :schema, :tables

  def initialize(schema_path)
    @schema_path = schema_path
    load_schema
  end

  def load_schema
    unless File.exist?(@schema_path)
      raise "Schema file not found: #{@schema_path}"
    end

    content = File.read(@schema_path)
    @schema = JSON.parse(content)
    @tables = @schema['tables'] || {}
  rescue JSON::ParserError => e
    raise "Invalid JSON in schema file: #{e.message}"
  end

  def table_names
    @tables.keys.sort
  end

  def get_table(table_name)
    @tables[table_name]
  end

  def search_tables(query)
    query_downcase = query.downcase
    matching_tables = []

    @tables.each do |table_name, table_data|
      # Search by table name
      if table_name.downcase.include?(query_downcase)
        matching_tables << {
          table: table_name,
          match_type: 'table_name',
          comment: table_data['comment']
        }
        next
      end

      # Search by column name
      table_data['columns']&.each do |column_name, column_data|
        if column_name.downcase.include?(query_downcase)
          matching_tables << {
            table: table_name,
            match_type: 'column_name',
            column: column_name,
            column_type: column_data['type'],
            comment: column_data['comment']
          }
        end
      end
    end

    matching_tables.uniq { |m| [m[:table], m[:column]] }
  end

  def get_foreign_keys(table_name)
    table = get_table(table_name)
    return [] unless table

    foreign_keys = []
    table['constraints']&.each do |constraint_name, constraint_data|
      if constraint_data['type'] == 'FOREIGN KEY'
        foreign_keys << {
          name: constraint_name,
          columns: constraint_data['columnNames'],
          target_table: constraint_data['targetTableName'],
          target_columns: constraint_data['targetColumnNames'],
          on_update: constraint_data['updateConstraint'],
          on_delete: constraint_data['deleteConstraint']
        }
      end
    end

    foreign_keys
  end

  def get_referencing_tables(table_name)
    referencing = []

    @tables.each do |other_table_name, other_table_data|
      next if other_table_name == table_name

      other_table_data['constraints']&.each do |constraint_name, constraint_data|
        if constraint_data['type'] == 'FOREIGN KEY' &&
           constraint_data['targetTableName'] == table_name
          referencing << {
            table: other_table_name,
            constraint: constraint_name,
            columns: constraint_data['columnNames'],
            target_columns: constraint_data['targetColumnNames']
          }
        end
      end
    end

    referencing
  end

  def analyze_dependencies(table_name)
    table = get_table(table_name)
    return nil unless table

    {
      table: table_name,
      foreign_keys: get_foreign_keys(table_name),
      referenced_by: get_referencing_tables(table_name),
      columns_count: table['columns']&.size || 0,
      indexes_count: table['indexes']&.size || 0
    }
  end
end

# Server setup
schema_path = ENV['SCHEMA_PATH']

# Set default path (relative to script location)
if !schema_path || schema_path.empty?
  script_dir = File.dirname(File.expand_path(__FILE__))
  schema_path = File.join(script_dir, '../dist/schema.json')
end

unless File.exist?(schema_path)
  STDERR.puts "Schema file not found: #{schema_path}"
  STDERR.puts "Please set SCHEMA_PATH environment variable"
  exit 1
end

schema_loader = SchemaLoader.new(schema_path)

# Define tools
class ListTablesTool < MCP::Tool
  description "Get a list of all tables in the schema"
  input_schema(
    type: "object",
    properties: {
      pattern: {
        type: "string",
        description: "Optional pattern to filter table names (case-insensitive)"
      }
    }
  )

  class << self
    attr_accessor :schema_loader

    def call(pattern: nil)
      tables = schema_loader.table_names

      if pattern
        pattern_downcase = pattern.downcase
        tables = tables.select { |t| t.downcase.include?(pattern_downcase) }
      end

      tables_text = tables.map.with_index(1) do |table, idx|
        table_data = schema_loader.get_table(table)
        columns_count = table_data['columns']&.size || 0
        "#{idx}. #{table} (#{columns_count} columns)"
      end.join("\n")

      MCP::Tool::Response.new([
        {
          type: "text",
          text: "Tables list (#{tables.size} tables):\n\n#{tables_text}"
        }
      ])
    rescue => e
      MCP::Tool::Response.new([
        {
          type: "text",
          text: "Error: #{e.message}\n#{e.backtrace.join("\n")}"
        }
      ])
    end
  end
end

class GetTableSchemaTool < MCP::Tool
  description "Get detailed schema information for a specific table"
  input_schema(
    type: "object",
    properties: {
      table_name: {
        type: "string",
        description: "Name of the table"
      }
    },
    required: ["table_name"]
  )

  class << self
    attr_accessor :schema_loader

    def call(table_name:)
      table = schema_loader.get_table(table_name)

      unless table
        return MCP::Tool::Response.new([
          { type: "text", text: "Table '#{table_name}' not found" }
        ])
      end

      # Columns
      columns_text = table['columns']&.map do |col_name, col_data|
        constraints = []
        constraints << "NOT NULL" if col_data['notNull']
        constraints << "DEFAULT: #{col_data['default']}" if col_data['default']

        constraint_str = constraints.empty? ? "" : " (#{constraints.join(', ')})"
        comment_str = col_data['comment'] ? "\n    Comment: #{col_data['comment']}" : ""

        "  - #{col_name}: #{col_data['type']}#{constraint_str}#{comment_str}"
      end&.join("\n") || "  No columns"

      # Indexes
      indexes_text = table['indexes']&.map do |idx_name, idx_data|
        unique_str = idx_data['unique'] ? " (UNIQUE)" : ""
        "  - #{idx_name}#{unique_str}\n    Columns: #{idx_data['columns'].join(', ')}"
      end&.join("\n") || "  No indexes"

      # Constraints
      constraints_text = table['constraints']&.map do |const_name, const_data|
        case const_data['type']
        when 'PRIMARY KEY'
          "  - #{const_name} (PRIMARY KEY)\n    Columns: #{const_data['columnNames'].join(', ')}"
        when 'FOREIGN KEY'
          "  - #{const_name} (FOREIGN KEY)\n    Columns: #{const_data['columnNames'].join(', ')}\n    References: #{const_data['targetTableName']}(#{const_data['targetColumnNames'].join(', ')})\n    On Update: #{const_data['updateConstraint']}, On Delete: #{const_data['deleteConstraint']}"
        when 'UNIQUE'
          "  - #{const_name} (UNIQUE)\n    Columns: #{const_data['columnNames'].join(', ')}"
        else
          "  - #{const_name} (#{const_data['type']})"
        end
      end&.join("\n") || "  No constraints"

      schema_text = <<~TEXT
        Table: #{table_name}
        #{table['comment'] ? "Comment: #{table['comment']}\n" : ""}
        Columns (#{table['columns']&.size || 0}):
        #{columns_text}

        Indexes (#{table['indexes']&.size || 0}):
        #{indexes_text}

        Constraints (#{table['constraints']&.size || 0}):
        #{constraints_text}
      TEXT

      MCP::Tool::Response.new([
        { type: "text", text: schema_text }
      ])
    rescue => e
      MCP::Tool::Response.new([
        {
          type: "text",
          text: "Error: #{e.message}\n#{e.backtrace.join("\n")}"
        }
      ])
    end
  end
end

class SearchTablesTool < MCP::Tool
  description "Search for tables by name or column name"
  input_schema(
    type: "object",
    properties: {
      query: {
        type: "string",
        description: "Search query (searches in table names and column names)"
      }
    },
    required: ["query"]
  )

  class << self
    attr_accessor :schema_loader

    def call(query:)
      results = schema_loader.search_tables(query)

      if results.empty?
        return MCP::Tool::Response.new([
          { type: "text", text: "No matches found for '#{query}'" }
        ])
      end

      # Group and display by table name
      grouped = results.group_by { |r| r[:table] }

      results_text = grouped.map do |table_name, matches|
        table_matches = matches.map do |match|
          case match[:match_type]
          when 'table_name'
            "  ✓ Table name matches"
          when 'column_name'
            "  ✓ Column: #{match[:column]} (#{match[:column_type]})"
          end
        end.join("\n")

        "#{table_name}:\n#{table_matches}"
      end.join("\n\n")

      MCP::Tool::Response.new([
        {
          type: "text",
          text: "Search results for '#{query}' (#{results.size} matches in #{grouped.size} tables):\n\n#{results_text}"
        }
      ])
    rescue => e
      MCP::Tool::Response.new([
        {
          type: "text",
          text: "Error: #{e.message}\n#{e.backtrace.join("\n")}"
        }
      ])
    end
  end
end

class GetTableRelationsTool < MCP::Tool
  description "Get foreign key relationships for a table"
  input_schema(
    type: "object",
    properties: {
      table_name: {
        type: "string",
        description: "Name of the table"
      }
    },
    required: ["table_name"]
  )

  class << self
    attr_accessor :schema_loader

    def call(table_name:)
      table = schema_loader.get_table(table_name)

      unless table
        return MCP::Tool::Response.new([
          { type: "text", text: "Table '#{table_name}' not found" }
        ])
      end

      foreign_keys = schema_loader.get_foreign_keys(table_name)
      referencing = schema_loader.get_referencing_tables(table_name)

      # Foreign keys (tables referenced by this table)
      fk_text = if foreign_keys.empty?
        "  None"
      else
        foreign_keys.map do |fk|
          "  - #{fk[:columns].join(', ')} → #{fk[:target_table]}(#{fk[:target_columns].join(', ')})\n" +
          "    Constraint: #{fk[:name]}\n" +
          "    On Update: #{fk[:on_update]}, On Delete: #{fk[:on_delete]}"
        end.join("\n\n")
      end

      # Referenced by (this table is referenced by other tables)
      ref_text = if referencing.empty?
        "  None"
      else
        referencing.map do |ref|
          "  - #{ref[:table]}.#{ref[:columns].join(', ')} → #{table_name}(#{ref[:target_columns].join(', ')})\n" +
          "    Constraint: #{ref[:constraint]}"
        end.join("\n\n")
      end

      relations_text = <<~TEXT
        Relations for table: #{table_name}

        Foreign Keys (this table references):
        #{fk_text}

        Referenced By (other tables reference this table):
        #{ref_text}
      TEXT

      MCP::Tool::Response.new([
        { type: "text", text: relations_text }
      ])
    rescue => e
      MCP::Tool::Response.new([
        {
          type: "text",
          text: "Error: #{e.message}\n#{e.backtrace.join("\n")}"
        }
      ])
    end
  end
end

class AnalyzeModelDependenciesTool < MCP::Tool
  description "Analyze model dependencies and relationships"
  input_schema(
    type: "object",
    properties: {
      table_name: {
        type: "string",
        description: "Name of the table to analyze"
      }
    },
    required: ["table_name"]
  )

  class << self
    attr_accessor :schema_loader

    def call(table_name:)
      analysis = schema_loader.analyze_dependencies(table_name)

      unless analysis
        return MCP::Tool::Response.new([
          { type: "text", text: "Table '#{table_name}' not found" }
        ])
      end

      # Generate dependency tree
      dependencies = []
      analysis[:foreign_keys].each do |fk|
        dependencies << "#{table_name} depends on #{fk[:target_table]}"
      end

      dependents = []
      analysis[:referenced_by].each do |ref|
        dependents << "#{ref[:table]} depends on #{table_name}"
      end

      analysis_text = <<~TEXT
        Dependency Analysis for: #{table_name}

        Basic Info:
        - Columns: #{analysis[:columns_count]}
        - Indexes: #{analysis[:indexes_count]}
        - Foreign Keys: #{analysis[:foreign_keys].size}
        - Referenced By: #{analysis[:referenced_by].size}

        Dependencies (tables this table depends on):
        #{dependencies.empty? ? "  None (standalone table)" : dependencies.map { |d| "  - #{d}" }.join("\n")}

        Dependents (tables that depend on this table):
        #{dependents.empty? ? "  None (not referenced)" : dependents.map { |d| "  - #{d}" }.join("\n")}

        Relationship Details:

        Foreign Keys:
        #{analysis[:foreign_keys].empty? ? "  None" : analysis[:foreign_keys].map { |fk|
          "  - #{fk[:columns].join(', ')} → #{fk[:target_table]}(#{fk[:target_columns].join(', ')})"
        }.join("\n")}

        Referenced By:
        #{analysis[:referenced_by].empty? ? "  None" : analysis[:referenced_by].map { |ref|
          "  - #{ref[:table]}.#{ref[:columns].join(', ')} → #{table_name}(#{ref[:target_columns].join(', ')})"
        }.join("\n")}
      TEXT

      MCP::Tool::Response.new([
        { type: "text", text: analysis_text }
      ])
    rescue => e
      MCP::Tool::Response.new([
        {
          type: "text",
          text: "Error: #{e.message}\n#{e.backtrace.join("\n")}"
        }
      ])
    end
  end
end

# Inject schema_loader into tool classes
ListTablesTool.schema_loader = schema_loader
GetTableSchemaTool.schema_loader = schema_loader
SearchTablesTool.schema_loader = schema_loader
GetTableRelationsTool.schema_loader = schema_loader
AnalyzeModelDependenciesTool.schema_loader = schema_loader

# Set up the server
server = MCP::Server.new(
  name: "mcp-liam",
  version: "1.0.0",
  tools: [
    ListTablesTool,
    GetTableSchemaTool,
    SearchTablesTool,
    GetTableRelationsTool,
    AnalyzeModelDependenciesTool
  ]
)

# Create and start the transport
transport = MCP::Server::Transports::StdioTransport.new(server)
transport.open
